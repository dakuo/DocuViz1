<!DOCTYPE HTML>
<html>
<head>
	<title>{{ APPLICATION_NAME }}</title>
	
	<link rel="stylesheet" href="//kubiwork.com/othersites/docuviz/css/global2.css"></link>
	<link rel="stylesheet" href="//ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/themes/start/jquery-ui.css" type="text/css" media="all"></link>
	<link rel="stylesheet" href="//kubiwork.com/othersites/docuviz/css/jquery.multiselect.css"></link>

	<script type="text/javascript">
	//For GAPI load check
	var pickerApiLoaded = false;
	(function() {
		var po = document.createElement('script');
		po.type = 'text/javascript';
		po.async = true;
		po.src = '//plus.google.com/js/client:plusone.js';

		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(po, s);

	})();
	</script>

	<!-- JavaScript specific to this application that is not related to API calls -->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" type="text/javascript"></script>
	<script src="//ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js" type="text/javascript"></script>
	<script src="//d3js.org/d3.v3.min.js" charset="utf-8" type="text/javascript"></script>
	<script src="//kubiwork.com/othersites/docuviz/js/jquery.multiselect.js" charset="utf-8" type="text/javascript"></script>
</head>

<body>

	<div class="site-wrap">
    <section class="billboard">
      <div class="billboard__image-wrap">
        <div class="billboard__image center-y image--homePage">
          <img src="http://kubiwork.com/othersites/docuviz/billboard.png" alt="Billboard">
        </div>
        <div class="billboard__image center-y image--uploadPage">
          <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="280" height="280" viewBox="0 0 280 280">

            <path class="path" fill="#F35A4E" stroke="white" stroke-width="2" stroke-miterlimit="10" d="M215.332 253.75c3.773 0 6.836-3.056 6.836-6.836 0 0 0-168.164 0-168.164 0-0.15-0.075-0.28-0.089-0.431-0.041-0.615-0.157-1.21-0.362-1.791-0.082-0.232-0.144-0.451-0.246-0.67-0.308-0.656-0.704-1.271-1.224-1.812-0.041-0.041-0.062-0.103-0.109-0.144-0.007-0.007-0.014-0.021-0.021-0.034 0 0-37.598-36.914-37.598-36.914-0.567-0.554-1.23-0.957-1.928-1.285-0.212-0.096-0.431-0.15-0.656-0.226-0.581-0.198-1.176-0.321-1.791-0.362-0.137-0.007-0.26-0.082-0.41-0.082 0 0-112.793 0-112.793 0-3.773 0-6.836 3.056-6.836 6.836 0 0 0 205.078 0 205.078 0 3.78 3.063 6.836 6.836 6.836 0 0 150.391 0 150.391 0s0 0 0 0zM184.57 58.133c0 0 14.041 13.788 14.041 13.788s-14.041 0-14.041 0c0 0 0-13.788 0-13.788s0 0 0 0zM71.777 48.672c0 0 99.121 0 99.121 0s0 30.078 0 30.078c0 3.78 3.063 6.836 6.836 6.836 0 0 30.762 0 30.762 0s0 154.492 0 154.492c0 0-136.719 0-136.719 0s0-191.406 0-191.406c0 0 0 0 0 0zM189.226 145.537c0 0-94.739 0-94.739 0-3.773 0-6.836 3.056-6.836 6.836s3.063 6.836 6.836 6.836c0 0 94.732 0 94.732 0 3.773 0 6.836-3.056 6.836-6.836s-3.056-6.836-6.829-6.836c0 0 0 0 0 0zM189.226 116.826c0 0-94.739 0-94.739 0-3.773 0-6.836 3.056-6.836 6.836s3.063 6.836 6.836 6.836c0 0 94.732 0 94.732 0 3.773 0 6.836-3.056 6.836-6.836s-3.056-6.836-6.829-6.836c0 0 0 0 0 0zM189.226 174.241c0 0-94.739 0-94.739 0-3.773 0-6.836 3.056-6.836 6.836s3.063 6.836 6.836 6.836c0 0 94.732 0 94.732 0 3.773 0 6.836-3.056 6.836-6.836s-3.056-6.836-6.829-6.836c0 0 0 0 0 0zM189.226 202.952c0 0-94.739 0-94.739 0-3.773 0-6.836 3.056-6.836 6.836s3.063 6.836 6.836 6.836c0 0 94.732 0 94.732 0 3.773 0 6.836-3.056 6.836-6.836s-3.056-6.836-6.829-6.836c0 0 0 0 0 0z" fill="#000000"></path>
          </svg>
        </div>
      </div>


      <div class="billboard__content-wrap">
        <div class="billboard__content center-y content--homePage">
          <h2 class="content__title">
            Docuviz
          </h2>

          <span class="content__description">
            DocuViz visualizes how a document evolves in Google Docs, showing who did what when. A user connects DocuViz with his Google Docs, selects a document and generates a visualization of the revision history of the document. A user can also interact with the diagram in various ways and save it. Potential uses of DocuViz include supporting collaborative writing, helping with students' process in learning to write, interpreting collaboration patterns and evaluating participation.DocuViz was developed by the Hana Lab at UC Irvine, including Dakuo Wang, Jingwen Zhang, Judy and Gary Olson, and Trung Nguyen.
			</br>
			The ideas in Docuviz are inspired by History Flow by Fernanda Viegas and Martin Wattenberg. The program is written in Java, and incorporates the API from Google Docs, the D3.js visualization library by Michael Bostock, and the text diff algorithm by Eugene Myers.
          </span>

          <!-- Google Log in Btn -->
          <div id="gConnect">
            <button class="g-signin"
            data-scope="email https://www.googleapis.com/auth/drive"
            data-clientId="{{ CLIENT_ID }}" data-accesstype="online"
            data-callback="onSignInCallback" data-theme="dark" data-width="wide"
            data-cookiepolicy="single_host_origin" data-approvalprompt="force"></button>
          </div>
        </div>

        <div class="billboard__content center-y content--uploadPage">

          <span class="content__description">
            Choose a Google Drive Document to see the revision history visualization
          </span>

          <a class="btn btn--skin-1 createPicker2">
            Choose a document
          </a>
        </div>
      </div>
    </section>


	<section class="loading-screen">
	  <div class="content center">
	    <progress class='progressBar' max='100' value='20'><span>0</span>%</progress>
	    <h2>Loading...</h2>
	  </div>

	  <!-- <div class="visual-log">
	    <h2>Visualization Log</h2>

	    <div class="log__content">
	      <span>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Repudiandae, quibusdam.</span>
	    </div>

	  </div> -->
	</section>


    <section class="docuviz-controller">
      <a class="createPicker2"><i class="icon icon-paper"></i><span>Choose Another Document</span></a>
      <a id="saveButton"><i class="icon icon-inbox"></i><span>Save Image</span></a>
    </section>


	<div id="authOps" style="display: none">
		<div id="progressBar" style="display:none"></div>
		<div id="slider" style="display:none">
			<section class="chart-component">
			  <section class="chart__controller">
			    <div class="controller__btn-wrap">
		             <input type="radio" id="equaldistance" name="radio" value="equaldistance" checked="checked">
		             <label for="equaldistance" class="btn btn--style-2">Equal Distance</label>

				     <input type="radio" id="timescale" name="radio" value="timescale">
				     <label for="timescale" class="btn btn--style-2">Time Scaled</label>
			    </div>

			    <div class="controller__slider">
			      <div class="slider__label">
			        <span id="amount">Rev 1</span>
			      </div>
			      <div class="slider-bar-wrap">
			      </div>
			    </div>
			  </section>
			</section>
		</div>
		<!-- The main Canvas for drawing the HistoryFlow  -->
		<pre id="vizChart"></pre>

  		<!-- Hidden <FORM> to submit the SVG data to the server, which will convert it to SVG/PDF/PNG downloadable file.
  		The form is populated and submitted by the JavaScript below. -->
  		<form id="svgform" method="post" action="saveImage">
  			<input type="hidden" id="output_format" name="output_format" value="">
  			<input type="hidden" id="data" name="data" value="">
  		</form>

  		<!--
  		<h2>Authentication Logs</h2>
  		<pre id="authResult"></pre>
  	-->
	  	<!--  Hidden Dialog FORM to submit the changing author request by Dakuo -->
	  	<div id="dialog_form" title="Change Segment Author">
	  		<form>
	  			<select id="author_list"></select>
	  			<input type="hidden" id="change_doc_id" name="doc_id" value="">
	  			<input type="hidden" id="change_seg_id" name="seg_id" value="">
	  			<input type="hidden" id="change_rev_id" name="rev_id" value="">
	  		</form>
	  	</div>
	  	<!--  Hidden Author Lableing Dialog FORM to submit the changing author labeling request by Dakuo-->
	  	<div id="authorlabel_dialog_form" title="Change Author Lable">
	  		<form>
	  			<select id="authorlabel_author_list" multiple="multiple"></select>
	  			<input type="hidden" id="authorlabel_change_doc_id" name="doc_id" value="">
	  			<input type="hidden" id="authorlabel_change_rev_id" name="rev_id" value="">
	  		</form>
	  	</div>
	  	<!-- Hidden Content dialog by Jingwen -->
	  	<div id="content" title="Content">
	  	</div>
  	
  </div>
</div>

</body>
<script type="text/javascript">


	var classesToRemoveFromSlider = ['ui-slider', 'ui-slider-horizontal', 'ui-widget', 'ui-widget-content', 'ui-corner-all', 'ui-slider-range', 'ui-widget-header', 'ui-slider-handle', 'ui-state-default'];

	var removeClassesCreateHandler = function(event, ui) {
		var that = this;
		$.each(classesToRemoveFromSlider, function(idx, val) {
			$('.' + val, that).removeClass(val);
		});
	};

	/**
	 * The helper functions to post AJAX call to backend server, by Dakuo
	 */	
	var helper = (function() {
		var authResult = undefined;
		return {
			/**
			 * Hides the sign-in button and connects the server-side app after
			 * the user successfully signs in.
			 *
			 * @param {Object} authResult An Object which contains the access token and
			 *   other authentication information.
			 */
			 onSignInCallback : function(authResult) {
				//TODO may be deleted after deployment
				$('#authResult').hide();

				// KUBI Components
				// $('.billboard').hide();
				$('.billboard__content-wrap').addClass('isActive');
        		$('.billboard__image-wrap').addClass('isActive');

				$('.loading-screen').hide();
        		$('.docuviz-controller').hide();

				// $('#authResult').html('Auth Result:<br/>');
				// for ( var field in authResult) {
				// 	//not work with chrome, but doesn't matter, just debug
				// 	//$('#authResult').append(' ' + field + ': ' + authResult[field] + '<br/>');
				// }

				if (authResult['access_token']) {
					// The user is signed in
					this.authResult = authResult;
					helper.connectServer();

					// After we load the Google+ API, render the profile data from Google+.
					gapi.client.load('plus', 'v1', this.renderProfile);

				} else if (authResult['error']) {
					// There was an error, which means the user is not signed in.
					// As an example, you can troubleshoot by writing to the console:
					console.log('There was an error: ' + authResult['error']);
					$('#authResult').append('Logged out');
					$('#authOps').hide('slow');
					$('#gConnect').show();
				}
				console.log('authResult', authResult);
			},

			/**
			 * Retrieves and renders the authenticated user's Google+ profile.
			 * For now, keep it for displaying the page after connect/re-connect
			 */
			 renderProfile : function() {
			 	var request = gapi.client.plus.people.get({
			 		'userId' : 'me'
			 	});
			 	request
			 	.execute(function(profile) {
			 		$('#profile').empty();
			 		if (profile.error) {
			 			$('#profile').append(profile.error);
			 			return;
			 		}
			 		$('#profile')
			 		.append(
			 			$('<p><img src=\"' + profile.image.url + '\"></img></p>'));
			 		$('#profile').append(
			 			$('<p>Hello ' + profile.displayName
			 				+ '!<br />Tagline: '
			 				+ profile.tagline + '<br />About: '
			 				+ profile.aboutMe + '</p>'));
			 		if (profile.cover && profile.coverPhoto) {
			 			$('#profile')
			 			.append(
			 				$('<p><img src=\"' + profile.cover.coverPhoto.url + '\"></img></p>'));
			 		}
			 	});
			 	$('#authOps').show('slow');
			 	$('#gConnect').hide();
			 },
			/**
			 * Calls the server endpoint to disconnect the app for the user.
			 */
			 disconnectServer : function() {
				// Revoke the server tokens
				$.ajax({
					type : 'POST',
					url : window.location.href + 'disconnect',
					async : false,
					success : function(result) {
						console.log('revoke response: ' + result);
						$('#authOps').hide('slow');

						//$('#profile').empty();
						//$('#visiblePeople').empty();

						$('#authResult').empty();
            			// $('.log__content').empty();
						$('#vizChart').empty();

						$('#slider').hide();
						$('#saveButton').attr("disabled",
							true);

						$('#gConnect').show();
					},
					error : function(e) {
						console.log(e);
					}
				});
			},
			/**
			 * Calls the server endpoint to connect the app for the user. The client
			 * sends the one-time authorization code to the server and the server
			 * exchanges the code for its own tokens to use for offline API access.
			 * For more information, see:
			 *   https://developers.google.com/+/web/signin/server-side-flow
			 */
			 connectServer : function() {
			 	console.log(this.authResult.code);
			 	$.ajax({
			 		type : 'POST',
			 		url : window.location.href + 'connect?state={{ STATE }}',
			 		contentType : 'application/octet-stream; charset=utf-8',
			 		success : function(result) {
			 			console.log(result);

						//helper.people();
					},
					processData : false,
					data : this.authResult.code
				});
			 },

			/**
			 * Create and render a Picker object for picking user Docs.
			 */
			 createPicker : function(oauthToken) {

				//For GAPI load check
				if (pickerApiLoaded && oauthToken) {

          			var docsView = new google.picker.DocsView(google.picker.ViewId.DOCUMENTS);
          			docsView.setIncludeFolders(true);

					var picker = new google.picker.PickerBuilder()
					.enableFeature(google.picker.Feature.NAV_HIDDEN)
					.addView(docsView)
					.setOAuthToken(oauthToken)
					.setDeveloperKey('AIzaSyCkhO5QlXxaVMmM3EqybZeC3BbFHGsxo20')
					.setCallback(
						function(data) {
							var doc_id = 'nothing';
							var doc_name = 'no name';
							if (data[google.picker.Response.ACTION] == google.picker.Action.PICKED) {
											// Deal with vizChart
											$("#slider").hide();

                      						$('.docuviz-controller').hide();

											$("#vizChart").empty();
											// $('.log__content').empty();


											$('.createPicker2').attr("disabled",
												true);
											$('#saveButton').attr("disabled",
												true);

											// Show Loading Page
											$('.loading-screen').show();

											$("#author_list").empty();
											$("#authorlabel_author_list").empty();

						                    // Hide Billboard
						                    $('.billboard').hide();

											/* [~] Hide Google Upload */
											$('.billboard__content-wrap').removeClass('isActive');
                      						$('.billboard__image-wrap').removeClass('isActive');

											var doc = data[google.picker.Response.DOCUMENTS][0];
											doc_id = doc[google.picker.Document.ID];
											doc_name = doc[google.picker.Document.NAME];
											helper.retrieveRevisions(doc_id,
												doc_name);

										} else {
											$('.createPicker2').attr("disabled",
												false);
										}
									}).build();
					picker.setVisible(true);
				} else {
					gapi.load('picker');
					pickerApiLoaded = true;
				}
			},
			/**
			 * Calls the server endpoint to start retrieve the list of revisions visible to this app.
			 */
			 retrieveRevisions : function(doc_id, doc_name) {

			 	// $('.log__content').append("<p>Viz Result for Document: " + doc_name + '</p>');

			 	$.post(window.location.href + 'revisions', {
			 		'doc_id' : doc_id,
			 		'doc_name' : doc_name
			 	}, function(result) {
			 		console.log("Start Retrieving Revisions");
			 		console.log(result);

			 		helper.pollingTask(doc_id, doc_name, 'download');
			 	});
			 },

			/**
			 * Calls the server endpoint to start diff the already downloaded revisions.
			 */
			 diffRevisions : function(doc_id, doc_name) {

			 	// $('.log__content').append('<p>Diff Result for Document: ' + doc_name + '</p>');
			 	$.post(window.location.href + 'diffrevisions', {
			 		'doc_id' : doc_id,
			 		'doc_name' : doc_name
			 	}, function(result) {
			 		console.log("Start Differentiating Revisions");
			 		console.log(result);

			 		// $('.log__content').append(result);

					//TODO will really process this sentence??
					if (helper.pollingTask(doc_id, doc_name, 'diff')){
						renderVisualization(doc_id, doc_name);
					}
				});

			 },
			/**
			 * Call the server endpoint to check the status of visualizing task
			 */
			 pollingTask : function(doc_id, doc_name, mode) {
			 	$.ajax({
			 		type : 'GET',
			 		url : window.location.href + 'polling?mode=' + mode
			 		+ '&doc_id=' + doc_id,
			 		contentType : 'application/octet-stream; charset=utf-8',

			 		success : function(result) {
			 			console.log("Polling Status of Task " + doc_id);
			 			console.log(result);

						// KUBI progressBar
			 			$('.progressBar').val(parseInt(result));

						if (mode === "download") {
							if (result === "100") {

								// $('.log__content').append('Download Done!');

								// TODO should be initiated in upper level not inside polling?
								// initiate the diff algorithm
								helper.diffRevisions(doc_id, doc_name);
								return;
							}
							// $('.log__content').append('Downloading ' + result + '%');

						} else if (mode === "diff") {
							if (result === "100") {
								$('.createPicker2').attr("disabled", false);
								$('#progressBar').hide();
								$('#saveButton').attr("disabled",false);
                				// $('.log__content').append('Diff Done! <br/>');

								// TODO should be initiated in upper level not inside polling?
								// initiate the viz
								helper.renderVisualization(doc_id, doc_name);
								return;
							}

              				// $('.log__content').append('Diff-ing ' + result + '%. <br/>');
						}

						helper.pollingTask(doc_id, doc_name, mode);
					}
				});
			},
			/**
			 * Retrieves and renders the history flow.
			 */
			 renderVisualization : function(doc_id, doc_name) {
		        $('.log__content').empty();
				$('#vizChart').empty();
		
		        $('.docuviz-controller').show();
				$('.loading-screen').hide();
		
		
		        // Remove bug from Slider Bar when switching document
		        $('.slider-bar-wrap').empty();
		
				$('#slider').hide();
		
		        // $('.log__content').append('Viz Result for Document: ' + doc_name + '<br/>');

			 	$('#change_doc_id').val(doc_id);

				$.ajax({
					type : 'POST',
					url : window.location.href + 'viz?doc_id=' + doc_id,
					contentType : 'application/octet-stream; charset=utf-8',
					success : function(result) {
						console.log("Start Viz Revisions");
                		$('.log__content').append(result + ' <br/>');

						/*
						 ** To Prepare the SVG Convas for drawing the history flow
						 */
						 var width = 1280, height = 900, margin = {
						 	'top' : 20,
						 	'right' : 10,
						 	'bottom' : 10,
						 	'left' : 10
						 };

						 var svg = d3.select("#vizChart").append("svg")
						 .attr(
						 	"width",
						 	width + margin.left
						 	+ margin.right)
						 .attr(
						 	"height",
						 	height + margin.top
						 	+ margin.bottom)
						 .attr(
						 	"margin-left",
						 	margin.left
						 	)
						 .attr(
						 	"margin-top",
						 	margin.top
						 	);

						/*
						 * Draw the history flow
						 */
						 var dataset = $.parseJSON(result);
						 historyflow(svg, width, height, dataset);

						 var num_revisions = dataset.revisions.length;

		                 /*
		                  * By Kubi: Another solution to remove Bug from Slider Bar when switching Document
		                  */
		                 $('.slider-bar-wrap').append('<div id="sliderBar" class="center-y slider-bar"></div>');

						 $("#sliderBar").slider({
						 	create: removeClassesCreateHandler,
						 	range: true,
						 	min: 1,
						 	max: num_revisions,
						 	values: [1,num_revisions],
						 	slide: function( event, ui ) {
					    		// revision start from 0, so we need to change the index minus one
					    		$( "#amount" ).text( "Rev " + ui.values[ 0 ] + " - Rev " + ui.values[ 1 ] );

								//TODO change ajax to post
								$.ajax({
									type : 'POST',
									url : window.location.href + 'viz?doc_id=' + doc_id+'&end_rev_index='+(ui.values[ 1 ]-1) +'&start_rev_index='+(ui.values[ 0 ]-1),
									contentType : 'application/octet-stream; charset=utf-8',
									success : function(result) {
										console.log("Start Viz Revisions");
                              			$('.log__content').append(result + ' <br/>');

										/*
										 ** To Prepare the SVG Convas for drawing the history flow
										 */
										 var width = 1280, height = 900, margin = {
										 	'top' : 20,
										 	'right' : 10,
										 	'bottom' : 10,
										 	'left' : 10
										 };

										 $('#vizChart').fadeOut(300,function(){
										 	$('#vizChart').empty();
										 	var svg = d3.select("#vizChart").append("svg")
										 	.attr(
										 		"width",
										 		width + margin.left
										 		+ margin.right)
										 	.attr(
										 		"height",
										 		height + margin.top
										 		+ margin.bottom)
										 	.attr(
										 		"margin-left",
										 		margin.left
										 		)
										 	.attr(
										 		"margin-top",
										 		margin.top
										 		);
											/*
											 * Draw the history flow
											 */
											 var dataset = $.parseJSON(result);
											 var timescale_flag = $('input[name=radio]:checked').val();

											 if(timescale_flag=="timescale")
											 	historyflow(svg, width, height, dataset, true);
											 else
											 	historyflow(svg, width, height, dataset, false);
											 $('#vizChart').fadeIn(300);
											});
										}
									});
								}
							});
						 	// END of the Slider

							$( "#amount" ).text( "Rev " + $( "#sliderBar" ).slider( "values", 0 ) +
								" - Rev " + $( "#sliderBar" ).slider( "values",  1) );
							$("#slider").show();

						},
						// END of AJAX call success function
						processData : false,
						data : this.authResult.code
					});
					// END of AJAX call
					$('#authOps').show('slow');
				},
				// END of renderVisualization funciton

			/*
			 *	get the segment content data
			 *
			 */
			 retrieveSegmentContent : function(doc_id, segment_id) {
     			// $('.log__content').empty();

			 	// $('.log__content').append(
			 	// 	'Selected Segment #' + segment_id
			 	// 	+ ' Content is: <br/>');

			 	var doOk = function() {
			 		$("#content").dialog("close");
			 	}

			 	var dialogOpts = {
			 		modal: true,
			 		buttons: {
			 			"Ok!": doOk
			 		},
			 		hight: 800,
			 		width: 500,
			 		autoOpen: false
			 	};
			 	$('#content').dialog(dialogOpts);

			 	$.ajax({
			 		type : 'POST',
			 		url : window.location.href + 'seg?doc_id=' + doc_id
			 		+ '&segment_id=' + segment_id,
			 		contentType : 'application/octet-stream; charset=utf-8',
			 		success : function(result) {
			 			console.log("Retrieved the Segment " + segment_id
			 				+ " Result ");

			 			// $('.log__content').append(result + ' <br/>');
			 			$('#content').html(result+'<span></span>');
			 		},
			 		processData : false,
			 		data : this.authResult.code
			 	});

			 	$('#content').removeClass('ui-dialog-buttonpane ui-widget-content ui-helper-clearfix');
			 	$('#content').dialog("open");
			 },

			/*
			 *	change the segment and all its children segments' author
			 *
			 */
			 changeSegmentAuthor : function(doc_id, revision_id, segment_id, author_id) {

			 	$.ajax({
			 		type : 'POST',
			 		url : window.location.href + 'segAuthor?doc_id=' + doc_id
			 		+ '&segment_id=' + segment_id + '&author_id=' + author_id + '&rev_id='+revision_id,
			 		contentType : 'application/octet-stream; charset=utf-8',
			 		success : function(result) {
			 			console.log("revision id: "+revision_id);
			 			// $('.log__content').append(result + ' <br/>');
			 		},
			 		processData : false,
			 		data : this.authResult.code
			 	});

			 	$('#vizChart').fadeOut(300,function(){
			 		$('#vizChart').empty();
					/*
					 ** To Prepare the SVG Convas for drawing the history flow
					 */
					 var width = 1280, height = 900, margin = {
					 	'top' : 20,
					 	'right' : 10,
					 	'bottom' : 10,
					 	'left' : 10
					 };
					 var svg = d3.select("#vizChart").append("svg")
					 .attr(
					 	"width",
					 	width + margin.left
					 	+ margin.right)
					 .attr(
					 	"height",
					 	height + margin.top
					 	+ margin.bottom)
					 .attr(
					 	"margin-left",
					 	margin.left
					 	)
					 .attr(
					 	"margin-top",
					 	margin.top
					 	);
					/*
					 * Draw the history flow
					 * refresh the chart
					 */
					$.ajax({
						type : 'POST',
						url : window.location.href + 'viz?doc_id=' + doc_id,
						contentType : 'application/octet-stream; charset=utf-8',
						success : function(result) {
							console.log("Start Redraw Visualization");

							var dataset = $.parseJSON(result);
							historyflow(svg, width, height, dataset);
							$('#vizChart').fadeIn(300);
						}
					});
				});
			},

			/*
			 * save the svg object to image locally
			 */
			saveImage : function() {
        		// $('.log__content').empty();
				// $('.log__content').append('Save Image <br/>');

				d3.select("svg").attr("version", 1.1).attr("xmlns","http://www.w3.org/2000/svg");
				var svg = document.getElementsByTagName('svg')[1];
				var svg_xml = (new XMLSerializer).serializeToString(svg);

				// Submit the <FORM> to the server.
				// The result will be an attachment file to download.
				var form = document.getElementById("svgform");
				form['output_format'].value = "";
				form['data'].value = svg_xml ;
				form.submit();
			}
		};
	})();
	// END of helper functions

	/**
	 *  UI
	 */

	/**
	 * Perform jQuery initialization and check to ensure that you updated your
	 * client ID.
	 */
	 $(document).ready(function() {
	 		/* By Kubi: Hide Google Upload */
		$('.billboard__content-wrap').removeClass('isActive');
		$('.billboard__image-wrap').removeClass('isActive');

 		$(".loading-screen").hide();
      	$(".docuviz-controller").hide();

 		$('input[name=radio]').click(function() {
			var value = $('input[name=radio]:checked').val();

 			if(value=="timescale")
 			{
 				$('#vizChart').fadeOut(300,function(){
					var doc_id = $('#change_doc_id').val();

 					$('#vizChart').empty();
					/*
					 ** To Prepare the SVG Convas for drawing the history flow
					 */
					 var width = 1280, height = 900, margin = {
					 	'top' : 20,
					 	'right' : 10,
					 	'bottom' : 10,
					 	'left' : 10
					 };
					 var svg = d3.select("#vizChart").append("svg")
					 .attr(
					 	"width",
					 	width + margin.left
					 	+ margin.right)
					 .attr(
					 	"height",
					 	height + margin.top
					 	+ margin.bottom)
					 .attr(
					 	"margin-left",
					 	margin.left
					 	)
					 .attr(
					 	"margin-top",
					 	margin.top
					 	);
					/*
					 * Draw the history flow
					 * refresh the chart
					 */
					$.ajax({
						type : 'POST',
						url : window.location.href + 'viz?doc_id=' + doc_id,
						contentType : 'application/octet-stream; charset=utf-8',
						success : function(result) {
							console.log("Start Redraw Visualization");

							var dataset = $.parseJSON(result);
							historyflow(svg, width, height, dataset, true);
							$('#vizChart').fadeIn(300);
						}
					});
				});
			}
			else{
				$('#vizChart').fadeOut(300,function(){
					$('#vizChart').empty();
					var doc_id = $('#change_doc_id').val();
					/*
					 ** To Prepare the SVG Convas for drawing the history flow
					 */
					 var width = 1280, height = 900, margin = {
					 	'top' : 20,
					 	'right' : 10,
					 	'bottom' : 10,
					 	'left' : 10
					 };
					 var svg = d3.select("#vizChart").append("svg")
					 .attr(
					 	"width",
					 	width + margin.left
					 	+ margin.right)
					 .attr(
					 	"height",
					 	height + margin.top
					 	+ margin.bottom)
					 .attr(
					 	"margin-left",
					 	margin.left
					 	)
					 .attr(
					 	"margin-top",
					 	margin.top
					 	);
					/*
					 * Draw the history flow
					 */
					// refresh the chart
					$.ajax({
						type : 'POST',
						url : window.location.href + 'viz?doc_id=' + doc_id,
						contentType : 'application/octet-stream; charset=utf-8',
						success : function(result) {
							console.log("Start Redraw Visualization");

							var dataset = $.parseJSON(result);
							historyflow(svg, width, height, dataset);
							$('#vizChart').fadeIn(300);
						}
					});
				});
			}
		});


		/*
		 * Fire an event after user chooses a file
		 */
		$('.createPicker2').click(createPicker);
		$('#saveButton').attr("disabled", true);
		$('#saveButton').click(helper.saveImage);

		/**
		 * Deal with progress bar
		 */
		$('.progressBar').val(0);

		/*
		 * Initiate the change author pop-up window
		 */
		$( "#dialog_form" ).dialog({
			autoOpen: false,
			height: 300,
			width: 500,
			modal: true,
			buttons: {
				"Show Content": function() {
					var doc_id = $('#change_doc_id').val();
					var seg_id = $('#change_seg_id').val();
					helper.retrieveSegmentContent(doc_id, seg_id);
					$( this ).dialog( "close" );
				},
				"Change Author": function() {
					var doc_id = $('#change_doc_id').val();
					var seg_id = $('#change_seg_id').val();
					var author_id = $('#author_list').val();
					var revision_id = $('#change_rev_id').val();
					helper.changeSegmentAuthor(doc_id, revision_id, seg_id, author_id);
					$( this ).dialog( "close" );
				},
				Cancel: function() {
					$( this ).dialog( "close" );
				}
			}
		});

		/*
		 * Initiate the authorlabel function pop-up window
		 */
		$( "#authorlabel_dialog_form" ).dialog({
			autoOpen: false,
			height: 300,
			width: 500,
			modal: true,
			buttons: {
				"Change Author Label": function() {
					var doc_id = $('#authorlabel_change_doc_id').val();
					//var seg_id = $('#authorlabel_change_seg_id').val();
					var author_id = $('#authorlabel_author_list').val();
					var revision_id = $('#authorlabel_change_rev_id').val();
					//helper.changeSegmentAuthor(doc_id, revision_id, seg_id, author_id);
					$( this ).dialog( "close" );
				},
				Cancel: function() {
					$( this ).dialog( "close" );
				}
			}
		});

		if($('[data-clientid="YOUR_CLIENT_ID"]').length > 0) {
		 	alert('This sample requires your OAuth credentials (client ID) '
		 		+ 'from the Google APIs console:\n'
		 		+ '    https://code.google.com/apis/console/#:access\n\n'
		 		+ 'Find and replace YOUR_CLIENT_ID with your client ID and '
		 		+ 'YOUR_CLIENT_SECRET with your client secret in the project sources.');
		}
	});
	// END of document.ready() function

	/**
	 * Calls the helper method that handles the authentication flow.
	 *
	 * @param {Object} authResult An Object which contains the access token and
	 *   other authentication information.
	 */
	 function onSignInCallback(authResult) {
	 	helper.onSignInCallback(authResult);
	 }

	 function onApiLoad() {
	 	gapi.load('picker');
	 	pickerApiLoaded = true;
	 	$('.createPicker2').attr("disabled", false);
	 	console.log("point0");
	 }

	 function createPicker() {
		$('.progressBar').val(0);
		console.log("point1");
		helper.createPicker(helper.authResult.access_token);
		return false;
	}

	// HistoryFlow Visualization Code
	function historyflow(svg, width, height, dataset, timescale_flag) {
		var color = d3.scale.category10(), margin = {
			'top' : 150,
			'right' : 20,
			'bottom' : (height / 8),
			'left' : 60
		}, barHeight = 10;

		/*
		 * Start the core visuzalization
		 */
		 var revisions = dataset.revisions;
		 var authors = dataset.authors;
		 var segments = dataset.segments;
		 var doc_id = dataset.docId;
		 var doc_name = dataset.docName;

		 timescale_flag = typeof timescale_flag !== 'undefined' ? timescale_flag : false;
		
		 // update the author_list for change segment author function
		 d3.select("#author_list")
		 .selectAll("option").data(authors).enter().append("option")
		 .attr("value", function(d,i){ return i; })
		 .text(function(d){ return d; });
		 
		 // update the authorlabel_author_list for change authorlabel function
		 d3.select("#authorlabel_author_list")
		 .selectAll("option").data(authors).enter().append("option")
		 .attr("value", function(d,i){ return i; })
		 .text(function(d){ return d; });
	     $('#authorlabel_author_list').multiselect();

		 var yScale = d3.scale.linear().domain(
		 	[ 0, d3.max(revisions, function(d) {
		 		return d.revisionLength;
		 	}) ]).range([ 0, height - margin.top - margin.bottom ]);

		 var yAxis = d3.svg.axis().scale(yScale).orient("right").ticks(10).tickFormat(d3.format("d"));
		 svg.append("g").attr("class", "axis").attr("transform",
		 	"translate(" + (margin.left - 55) + "," + margin.top + ")")
		 .call(yAxis);

		// the yAxis ending tick
		svg.append("text").attr("transform",
				"translate(" + 15 + "," + (height-margin.bottom) + ")").text(d3.max(revisions, function(d) {
					return d.revisionLength;
				}));

		var legend = svg.selectAll("authorGroup").data(authors).enter().append(
		 	"rect").attr("class", "segment").attr("x", 0).attr("y",
		 	function(d, i) {
		 		return i * (barHeight + 5 );
		 	})
		 	.attr("width", 40)
		 	.attr("height", barHeight).attr(
		 		"fill", function(d, i) {
		 			return color(i);
		 		}).attr(
		 		"transform",
		 		"translate(" + (margin.left )+ ","
		 			+ (height - margin.bottom ) + ")");

		// var author contribution in the final revision
		var authorContribution = [];
		for (var i=0;i<authors.length;i++){
			authorContribution[i]=0;
		}
		revisions[revisions.length-1].segments.forEach(function(element){
			authorContribution[segments[element].authorId] += segments[element].segmentLength;
		});

		var legendText = svg.selectAll("authorText").data(authors).enter()
			.append("text").attr("x", 40 + 10).attr("y", function(d, i) {
				return i * (barHeight + 5);
			})
			.attr("font-family", "sans-serif").attr("font-size", "16px")
			.attr("fill", "black").text(
					function(d, i) {
						return d + " " + authorContribution[i];
					}).attr(
					"transform",
					"translate(" + (margin.left )
							+ "," + (height - margin.bottom + (barHeight ) ) + ")");

		var titleText = svg.append("text").attr("x",11).attr("y",16).attr("font-family", "sans-serif").attr("font-size", "20px").text(""+doc_name);
		
		/*
		 * Equal Distance Rendering
		 */
		if(timescale_flag==false){
			var xScale = d3.scale.ordinal().domain(d3.range(revisions.length)).rangeRoundBands([ 0, width - margin.left - margin.right ], 0.5);

			// time
			var dateLabel2 = svg.selectAll("dateLabel2").data(revisions).enter()
			.append("text").attr("x", function(d, i) {
				return 0;
			}).attr("y", function(d, i) {
				return xScale(i);
			}).attr("font-family", "sans-serif")
			.attr("font-size", "14px")
			.attr("fill", "black")
			.html(
				function(d) {
					return d.time.substring(5, 10) + " " + d.time.substring(11, 16);
				})
			.attr("transform","translate(" + (margin.left + 15) + "," + (margin.top- (5*barHeight)) + ") rotate(-90)");

			/**
			 * Draw the multi author labl on top of each one
			 */
			 for(var index = 0; index< revisions.length; index++){
			 	var rev = revisions[index];
				//deal with multi author
				if($.isArray(rev.authorId)){
					svg.selectAll("authorLabel_"+index).data(rev.authorId).enter().append("rect")
					.attr("x", function() {
						return xScale(index);
					})
					.attr("y", function(d,i){
						return i*(barHeight + 1);
					})
					.attr("width", xScale.rangeBand())
					.attr("height", barHeight)
					.style("fill", function(d, i) {
						return color(d);
					})
					.attr(
						"transform", "translate(" + margin.left + "," + (margin.top - (5*barHeight))
							+ ")")
					//work on the "authors on but not doing editing thing, changes will only effect the author label"
					.on("click", function(d) {
						$('#authorlabel_change_doc_id').val(doc_id);
						//$('#change_seg_id_author').val(d);
						$('#authorlabel_change_rev_id').val(index);
						$('#authorlabel_dialog_form').dialog( "open" );	
					});
				}
				//deal with the old version single author heritage
				else{
					svg.append("rect")
					.attr("x", function() {
						return xScale(index);
					})
					.attr("y", 0)
					.attr("width", xScale.rangeBand())
					.attr("height", barHeight)
					.style("fill",  function(){
						return color(rev.authorId);
					})
					.attr(
						"transform", "translate(" + margin.left + "," + (margin.top - (5*barHeight))
							+ ")")
					//work on the "authors on but not doing editing thing, changes will only effect the author label"
					.on("click", function() {
						$('#authorlabel_change_doc_id').val(doc_id);
						//$('#change_seg_id_author').val(d);
						$('#authorlabel_change_rev_id').val(index);
						$('#authorlabel_dialog_form').dialog( "open" );	
					});
				}
			}


			// segment rectangles
			var groups = svg.selectAll("rectGroup").data(revisions).enter().append(
				"g").attr("class", "rectGroup").attr("transform",
				"translate(" + margin.left + "," + margin.top + ")");
	
			var revisionIndex = -1, revisionIndex2 = -1; //one for calculating x; one for calculating rev_index
			var accumulateSegLength = 0;
			var displayGroups = function(groups, start, end) {
				return groups
				.filter(function(d, i) {
					return i >= start && i <= end;
				})
				.selectAll("rect")
				.data(function(d) {
					if (d.segments.length != 0)
						return d.segments;
					else
						return [ -1 ];
				})
				.enter()
				.append("rect")
				.attr("class", "segment")
				.attr("x", function(d, i) {
					if (i == 0)
						revisionIndex++;
					return xScale(revisionIndex);
				})
				.attr("rev",function(d, i) {
					if (i == 0)
						revisionIndex2++;
					return revisionIndex2;
				})
				.attr(
					"y",
					function(d, i) {
						if (i == 0) {
							if (d == -1)
								return yScale(0);
							else {
								accumulateSegLength = segments[d].segmentLength;
								return yScale(accumulateSegLength
									- segments[d].segmentLength);
							}
						} else {
							accumulateSegLength += segments[d].segmentLength;
							return yScale(accumulateSegLength
								- segments[d].segmentLength);
						}
					})
				.attr("width", xScale.rangeBand())
				.attr("height",
					function(d) {
						if (d == -1)
							return 0;
						else
							return yScale(segments[d].segmentLength);
					})
				.attr("fill", function(d, i) {
					if (d != -1)
						return color(segments[d].authorId)
				})
				.on("click", function(d,i) {
					$('#change_doc_id').val(doc_id);
					$('#change_seg_id').val(d);
					$('#change_rev_id').val($(this).attr("rev"));
					$( "#dialog_form" ).dialog( "open" );
	
				});
	
			}
	
			displayGroups(groups, 0, 100);
	
			//===============================
			var link = [], preSegment = [];
			for (var j = 0; j < revisions.length - 1; j++) {
				link[j] = [];//link[j] represent the link between revision j and j+1
				preSegment = revisions[j].segments; //revision j segments
				newSegment = revisions[j + 1].segments; //revision j+1 segments
				//iterate revision j+1 segments to find father segment (segmentId) or it own(-1) in the previous revision
				for (var k = 0; k < newSegment.length; k++) {
					// If fatherSegmentIndex<0, it is not a child segment, either has a link to itself, or no link
					if (segments[newSegment[k]].fatherSegmentIndex < 0) {
						preIndex = preSegment.indexOf(newSegment[k]);
						//preIndex = -1 means that the segment is not in the previous revision
						if (preIndex != -1) {
							link[j].push([ preSegment[preIndex], newSegment[k] ]);
						} else {
							//No link
						}
					} else {
						// fatherSegmentIndex>0 it's a child segment, need to calculate the offset and position
						preIndex = preSegment
						.indexOf(segments[newSegment[k]].fatherSegmentIndex);
						//If preindex != -1 means, the father is in previous revision, so link the fathter segment and child segment
						if (preIndex != -1) {
							link[j].push([ preSegment[preIndex], newSegment[k] ]);
						}
						// If preindex = -1 means, the father is not in previous revision, so link the child segment and itself in previsous version
						else {
							preIndex = preSegment.indexOf(newSegment[k]);
							if (preIndex != -1) {
								link[j]
								.push([ preSegment[preIndex], newSegment[k] ]);
							} else {
								// means it has a father, but it's not in previous version,
								alert("link compute error" + preIndex + " "
									+ segments[newSegment[k]]);
								//console.log(segments[newSegment[k]]);
							}
						}
					}
				}//end of Segments  for loop
				// If there's no link at all, put a empty link for visualize reason
				if (link[j].length == 0) {
					link[j].push([ -1, -1 ]);
				}
			}// End of Revisions For loop
	
			var linkGroups = svg.selectAll("linkGroup").data(link).enter().append(
				"g").attr("class", "linkGroup").attr(
				"transform",
				"translate(" + (margin.left + xScale.rangeBand()) + ","
					+ margin.top + ")");
	
			var linkRevisionIndex = -1;
			var displayLinks = function(linkGroups, start1, end1) {
				return linkGroups
				.filter(function(d, i) {
					return i >= start1 && i <= end1;
				})
				.selectAll("link")
				.data(function(d) {
					return d;
				})
				.enter()
				.append("path")
				.attr("class", "link")
				.attr(
					"d",
					function(d, i) {
						if (i == 0) {
							linkRevisionIndex++;
							accumulateSegLength1 = 0;
							accumulateSegLength2 = 0;
						}
						// If d[1] = -1 means it has only an empty link (-1,-1)
						if (d[1] == -1) {
							return "";
						} else {
							x0 = xScale(linkRevisionIndex);
							var tempSegments1 = revisions[linkRevisionIndex].segments;
							var tempSegments2 = revisions[linkRevisionIndex + 1].segments;

							var index1 = tempSegments1.indexOf(d[0]);
							var index2 = tempSegments2.indexOf(d[1]);

							var accumulateSegLength1 = 0, accumulateSegLength2 = 0;

							for (var q = 0; q < index1; q++) {
								accumulateSegLength1 += segments[tempSegments1[q]].segmentLength;
							}
							for (var q = 0; q < index2; q++) {
								accumulateSegLength2 += segments[tempSegments2[q]].segmentLength;
							}

							if (d[1] == d[0]) {
								y0 = yScale(accumulateSegLength1);
							} else {
								y0 = yScale(accumulateSegLength1
									+ segments[d[1]].offsetInFatherSegment);
							}
							y1 = yScale(accumulateSegLength2);

							x1 = x0 + xScale.rangeBand();
							dy = yScale(segments[d[1]].segmentLength);

							return "M " + x0 + "," + y0 + " " + x0
							+ "," + (y0 + dy) + " " + x1 + ","
							+ (y1 + dy) + " " + x1 + "," + y1
							+ "Z";
						}

					}).attr("fill", function(d, i) {
						if (d[1] != -1)
							return color(segments[d[1]].authorId);
					}).attr("opacity", 0.8);

				}
	
				displayLinks(linkGroups, 0, 100);
			}
		/* generate timescale historyflow instead of equaling distance */
		else{

			var mindate = new Date(revisions[0].time),maxdate = new Date(revisions[(revisions.length-1)].time);
			var xScale = d3.time.scale().domain([mindate, maxdate])
			.range([ 0, width - margin.left - margin.right ]);
			var barWidth = 5;

			// time
			var dateLabel2 = svg.selectAll("dateLabel2").data(revisions).enter()
			.append("text")
			.attr("x", function(d, i) {
				return 0;
			})
			.attr("y", function(d, i) {
				return xScale(new Date(d.time));
			})
			.attr("font-family", "sans-serif").attr("font-size", "14px")
			.attr("fill", "black").html(
				function(d) {
					return d.time.substring(5, 10) + " " + d.time.substring(11, 16);
				}).attr(
	
				"transform","translate(" + (margin.left + 10) + "," + (margin.top-(5*barHeight)) + ") rotate(-90)");

			/**
			 * Draw the multi author labl on top of each one
			 */
			 for(var index=0; index< revisions.length; index++){
			 	var rev = revisions[index];
				//deal with multi author
				if($.isArray(rev.authorId)){
					svg.selectAll("authorLabel_"+index).data(rev.authorId).enter().append("rect")
					.attr("x", function() {
						return xScale(new Date(rev.time));
					})
					.attr("y", function(d,i){return (barHeight+1)*i;})
					.attr("width", barWidth)
					.attr("height", barHeight)
					.style("fill", function(d, i) {
						return color(d);
					})
					.attr(
						"transform", "translate(" + margin.left + "," + (margin.top - (5*barHeight))
							+ ")")//work on the "authors on but not doing editing thing, changes will only effect the author label"
					.on("click", function(d) {
						$('#authorlabel_change_doc_id').val(doc_id);
						//$('#change_seg_id_author').val(d);
						$('#authorlabel_change_rev_id').val(index);
						$('#authorlabel_dialog_form').dialog("open");	
					});
				}
				
				//deal with the old version single author heritage
				else{
					svg.append("rect")
					.attr("x", function() {
						return xScale(new Date(rev.time));
					})
					.attr("y", 0)
					.attr("width", barWidth)
					.attr("height", barHeight)
					.style("fill",  function(){
						return color(rev.authorId);
					})
					.attr(
						"transform", "translate(" + margin.left + "," + (margin.top - (5*barHeight))
							+ ")")
					.on("click", function() {
						$('#authorlabel_change_doc_id').val(doc_id);
						//$('#change_seg_id_author').val(d);
						$('#authorlabel_change_rev_id').val(index);
						$('#authorlabel_dialog_form').dialog( "open" );	
					});
				}
				
			}

			var groups = svg.selectAll("rectGroup").data(revisions).enter().append(
				"g").attr("class", "rectGroup").attr("transform",
				"translate(" + margin.left + "," + margin.top + ")");

			var revisionIndex = -1, revisionIndex2 = -1;
			var accumulateSegLength = 0;
			var displayGroups = function(groups, start, end) {
				return groups
				.filter(function(d, i) {
					return i >= start && i <= end;
				})
				.selectAll("rect")
				.data(function(d) {
					if (d.segments.length != 0)
						return d.segments;
					else
						return [ -1 ];
				})
				.enter()
				.append("rect")
				.attr("class", "segment")
				.attr("x", function(d, i) {
					if (i == 0)
						revisionIndex++;
					return xScale(new Date(revisions[revisionIndex].time));
				})
				.attr("rev",function(d, i) {
					if (i == 0)
						revisionIndex2++;
					return revisionIndex2;
				})
				.attr(
					"y",
					function(d, i) {
						if (i == 0) {
							if (d == -1)
								return yScale(0);
							else {
								accumulateSegLength = segments[d].segmentLength;
								return yScale(accumulateSegLength
									- segments[d].segmentLength);
							}
						} else {
							accumulateSegLength += segments[d].segmentLength;
							return yScale(accumulateSegLength
								- segments[d].segmentLength);
						}
					}).attr("width", barWidth).attr("height",
					function(d) {
						if (d == -1)
							return 0;
						else
							return yScale(segments[d].segmentLength);
					}).attr("fill", function(d, i) {
						if (d != -1)
							return color(segments[d].authorId)
					}).on("click", function(d) {
						$('#change_doc_id').val(doc_id);
						$('#change_seg_id').val(d);
						$('#change_rev_id').val($(this).attr("rev"));
						$( '#dialog_form' ).dialog( "open" );
		
					});
				}
		
				displayGroups(groups, 0, 100);
		
				//===============================
				var link = [], preSegment = [];
				for (var j = 0; j < revisions.length - 1; j++) {
					link[j] = [];//link[j] represent the link between revision j and j+1
					preSegment = revisions[j].segments; //revision j segments
					newSegment = revisions[j + 1].segments; //revision j+1 segments
					//iterate revision j+1 segments to find father segment (segmentId) or it own(-1) in the previous revision
					for (var k = 0; k < newSegment.length; k++) {
						// If fatherSegmentIndex<0, it is not a child segment, either has a link to itself, or no link
						if (segments[newSegment[k]].fatherSegmentIndex < 0) {
							preIndex = preSegment.indexOf(newSegment[k]);
							//preIndex = -1 means that the segment is not in the previous revision
							if (preIndex != -1) {
								link[j].push([ preSegment[preIndex], newSegment[k] ]);
							} else {
								//No link
							}
						} else {
							// fatherSegmentIndex>0 it's a child segment, need to calculate the offset and position
							preIndex = preSegment
							.indexOf(segments[newSegment[k]].fatherSegmentIndex);
							//If preindex != -1 means, the father is in previous revision, so link the fathter segment and child segment
							if (preIndex != -1) {
								link[j].push([ preSegment[preIndex], newSegment[k] ]);
							}
							// If preindex = -1 means, the father is not in previous revision, so link the child segment and itself in previsous version
							else {
								preIndex = preSegment.indexOf(newSegment[k]);
								if (preIndex != -1) {
									link[j]
									.push([ preSegment[preIndex], newSegment[k] ]);
								} else {
									// means it has a father, but it's not in previous version,
									alert("link compute error" + preIndex + " "
										+ segments[newSegment[k]]);
									//console.log(segments[newSegment[k]]);
								}
							}
						}
					}//end of Segments  for loop
					// If there's no link at all, put a empty link for visualize reason
					if (link[j].length == 0) {
						link[j].push([ -1, -1 ]);
					}
				}// End of Revisions For loop
		
				var linkGroups = svg.selectAll("linkGroup").data(link).enter().append(
					"g").attr("class", "linkGroup").attr(
					"transform",
					"translate(" + (margin.left + barWidth) + ","
						+ margin.top + ")");

				var linkRevisionIndex = -1;
				var displayLinks = function(linkGroups, start1, end1) {
					return linkGroups
					.filter(function(d, i) {
						return i >= start1 && i <= end1;
					})
					.selectAll("link")
					.data(function(d) {
						return d;
					})
					.enter()
					.append("path")
					.attr("class", "link")
					.attr(
						"d",
						function(d, i) {
							if (i == 0) {
								linkRevisionIndex++;
								accumulateSegLength1 = 0;
								accumulateSegLength2 = 0;
							}
							// If d[1] = -1 means it has only an empty link (-1,-1)
							if (d[1] == -1) {
								return "";
							} else {
								x0 = xScale(new Date(revisions[linkRevisionIndex].time));
								var tempSegments1 = revisions[linkRevisionIndex].segments;
								var tempSegments2 = revisions[linkRevisionIndex + 1].segments;

								var index1 = tempSegments1.indexOf(d[0]);
								var index2 = tempSegments2.indexOf(d[1]);

								var accumulateSegLength1 = 0, accumulateSegLength2 = 0;

								for (var q = 0; q < index1; q++) {
									accumulateSegLength1 += segments[tempSegments1[q]].segmentLength;
								}
								for (var q = 0; q < index2; q++) {
									accumulateSegLength2 += segments[tempSegments2[q]].segmentLength;
								}

								if (d[1] == d[0]) {
									y0 = yScale(accumulateSegLength1);
								} else {
									y0 = yScale(accumulateSegLength1
										+ segments[d[1]].offsetInFatherSegment);
								}
								y1 = yScale(accumulateSegLength2);

								x1 = xScale(new Date(revisions[linkRevisionIndex+1].time));
								dy = yScale(segments[d[1]].segmentLength);

								return "M " + x0 + "," + y0 + " " + x0
								+ "," + (y0 + dy) + " " + x1 + ","
								+ (y1 + dy) + " " + x1 + "," + y1
								+ "Z";
							}
						}).attr("fill", function(d, i) {
							if (d[1] != -1)
								return color(segments[d[1]].authorId);
						}).attr("opacity", 0.8);
					}
	
					displayLinks(linkGroups, 0, 100);
				}
			// END of Generating Time scale historyflow
		}
		// END of the historyflow funciton
	</script>
	<script src="//apis.google.com/js/api.js?onload=onApiLoad" type="text/javascript"></script>
</html>
